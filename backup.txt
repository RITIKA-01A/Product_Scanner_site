# # # from fastapi import FastAPI, File, UploadFile
# # # from fastapi.middleware.cors import CORSMiddleware
# # # from pydantic import BaseModel
# # # from PIL import Image
# # # import io
# # # import json
# # # import google.generativeai as genai
# # # import pymysql
# # # import re

# # # # --- Gemini + DB Configs ---
# # # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # # model = genai.GenerativeModel("gemini-2.0-flash")

# # # DB_CONFIG = {
# # #     "host": "localhost",
# # #     "user": "root",
# # #     "password": "ritik@01A",
# # #     "database": "product_database"
# # # }

# # # # --- Insert into DB ---
# # # def insert_into_database(data):
# # #     try:
# # #         conn = pymysql.connect(**DB_CONFIG)
# # #         cursor = conn.cursor()
# # #         query = """
# # #             INSERT INTO product_info (name, brand, product_type, size, expiry, price, sku)
# # #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# # #         """
# # #         values = (
# # #             data.get("name", ""),
# # #             data.get("brand", ""),
# # #             data.get("product_type", ""),
# # #             data.get("size", ""),
# # #             data.get("expiry", ""),
# # #             data.get("price", ""),
# # #             data.get("sku", "")
# # #         )
# # #         cursor.execute(query, values)
# # #         conn.commit()
# # #         conn.close()
# # #         print("‚úÖ Inserted into DB.")
# # #     except Exception as e:
# # #         print("‚ùå DB Error:", e)

# # # # --- Extract from Image ---
# # # def extract_info_from_image(image_bytes):
# # #     try:
# # #         pil_image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
# # #         response = model.generate_content(
# # #             [
# # #                 """You are an AI OCR system. From the image provided, extract product details and output ONLY a JSON object with the following keys: 
# # #                 name, brand, product_type, size, expiry, price, sku.
# # #                 Return only the JSON object. Do not include any explanation or markdown formatting like ```.""",
# # #                 pil_image
# # #             ],
# # #             generation_config={
# # #                 "temperature": 0.3,
# # #                 "top_p": 1,
# # #                 "top_k": 40,
# # #                 "max_output_tokens": 512,
# # #             },
# # #             safety_settings={
# # #                 "HARASSMENT": "block_none",
# # #                 "HATE": "block_none",
# # #                 "SEXUAL": "block_none",
# # #                 "DANGEROUS": "block_none",
# # #             }
# # #         )

# # #         raw_text = response.text.strip()
# # #         print("üîç Gemini Response:", repr(raw_text))

# # #         match = re.search(r"\{[\s\S]*\}", raw_text)
# # #         if match:
# # #             json_data = match.group(0)
# # #             return json.loads(json_data)
# # #         else:
# # #             print("‚ö† No valid JSON object found in Gemini response.")
# # #             return {"raw_response": raw_text, "error": "No valid JSON object found"}
# # #     except Exception as e:
# # #         print("‚ùå Gemini Error:", e)
# # #         return {"raw_response": "", "error": str(e)}

# # # # --- FastAPI App ---
# # # app = FastAPI()

# # # # --- CORS ---
# # # app.add_middleware(
# # #     CORSMiddleware,
# # #     allow_origins=["http://localhost:3000"],  # Replace with your frontend IP
# # #     allow_credentials=True,
# # #     allow_methods=["*"],
# # #     allow_headers=["*"],
# # # )

# # # # --- Image Upload Endpoint ---
# # # @app.post("/scan-image")
# # # async def scan_image(file: UploadFile = File(...)):
# # #     try:
# # #         print("called")
# # #         image_bytes = await file.read()
# # #         extracted_data = extract_info_from_image(image_bytes)
# # #         if "error" not in extracted_data:
# # #             insert_into_database(extracted_data)
# # #             return {"message": "Image scanned and saved", "data": extracted_data}
# # #         else:
# # #             return {"message": "Failed to extract data", "data": extracted_data}
# # #     except Exception as e:
# # #         return {"error": str(e)}





# # # # # # # from fastapi import FastAPI, HTTPException
# # # # # # # from fastapi.responses import JSONResponse
# # # # # # # from fastapi.middleware.cors import CORSMiddleware
# # # # # # # import cv2
# # # # # # # import json
# # # # # # # from PIL import Image
# # # # # # # import google.generativeai as genai

# # # # # # # # üîê Gemini Config
# # # # # # # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # # # # # # model = genai.GenerativeModel("gemini-2.0-flash")

# # # # # # # app = FastAPI()

# # # # # # # # Add CORS middleware
# # # # # # # origins = [
# # # # # # #     # "http://localhost",  # allow localhost
# # # # # # #     "http://localhost:3000",  # for frontend dev server, if applicable
# # # # # # #     "*",  # allow all origins (use with caution in production)
# # # # # # # ]

# # # # # # # app.add_middleware(
# # # # # # #     CORSMiddleware,
# # # # # # #     allow_origins=origins,  # List of allowed origins
# # # # # # #     allow_credentials=True,
# # # # # # #     allow_methods=["*"],  # Allow all methods (GET, POST, etc.)
# # # # # # #     allow_headers=["*"],  # Allow all headers
# # # # # # # )

# # # # # # # def extract_product_info_from_image(frame):
# # # # # # #     pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
# # # # # # #     try:
# # # # # # #         response = model.generate_content([ 
# # # # # # #             "Extract the product details from this image in JSON format. Only return JSON with keys: name, brand, product_type, size, expiry, price, sku.",
# # # # # # #             pil_image
# # # # # # #         ])
# # # # # # #         raw_text = response.text.strip()
# # # # # # #         if raw_text.startswith("```json"):
# # # # # # #             raw_text = raw_text.replace("```json", "").replace("```", "").strip()

# # # # # # #         data = json.loads(raw_text)

# # # # # # #         if isinstance(data, list):
# # # # # # #             data = sorted(data, key=lambda x: sum(bool(v) for v in x.values()), reverse=True)[0]

# # # # # # #         return {"status": "success", "data": data}

# # # # # # #     except Exception as e:
# # # # # # #         return {"status": "error", "message": str(e)}

# # # # # # # @app.post("/capture")
# # # # # # # def capture_and_extract():
# # # # # # #     cap = cv2.VideoCapture(0)
# # # # # # #     if not cap.isOpened():
# # # # # # #         raise HTTPException(status_code=500, detail="Failed to open camera")

# # # # # # #     ret, frame = cap.read()
# # # # # # #     cap.release()

# # # # # # #     if not ret:
# # # # # # #         raise HTTPException(status_code=500, detail="Failed to capture image")

# # # # # # #     result = extract_product_info_from_image(frame)

# # # # # # #     if result["status"] == "success":
# # # # # # #         return JSONResponse(content=result)
# # # # # # #     else:
# # # # # # #         raise HTTPException(status_code=500, detail=result["message"])
    


# # # # # # ##### THIS IS THE API CODE FOR STORING JSON RESPONSE INTO THE DATABASE 
# # # # # # # from flask import Flask, request, jsonify
# # # # # # # import pymysql
# # # # # # # import json
# # # # # # # from datetime import datetime

# # # # # # # app = Flask(__name__)

# # # # # # # # MySQL configuration
# # # # # # # MYSQL_HOST = "localhost"
# # # # # # # MYSQL_USER = "root"
# # # # # # # MYSQL_PASSWORD = "ritik@01A"
# # # # # # # DATABASE_NAME = "scanner"
# # # # # # # TABLE_NAME = "products"

# # # # # # # # Setup database and table
# # # # # # # def setup_mysql():
# # # # # # #     conn = pymysql.connect(
# # # # # # #         host=MYSQL_HOST,
# # # # # # #         user=MYSQL_USER,
# # # # # # #         password=MYSQL_PASSWORD
# # # # # # #     )
# # # # # # #     try:
# # # # # # #         with conn.cursor() as cursor:
# # # # # # #             cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DATABASE_NAME}")
# # # # # # #         conn.commit()
# # # # # # #     finally:
# # # # # # #         conn.close()

# # # # # # #     conn = pymysql.connect(
# # # # # # #         host=MYSQL_HOST,
# # # # # # #         user=MYSQL_USER,
# # # # # # #         password=MYSQL_PASSWORD,
# # # # # # #         database=DATABASE_NAME
# # # # # # #     )
# # # # # # #     try:
# # # # # # #         with conn.cursor() as cursor:
# # # # # # #             cursor.execute(f"""
# # # # # # #                 CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
# # # # # # #                     id INT AUTO_INCREMENT PRIMARY KEY,
# # # # # # #                     name VARCHAR(255),
# # # # # # #                     brand VARCHAR(255),
# # # # # # #                     product_type VARCHAR(100),
# # # # # # #                     size VARCHAR(50),
# # # # # # #                     expiry DATE,
# # # # # # #                     price DECIMAL(10,2),
# # # # # # #                     sku VARCHAR(50)
# # # # # # #                 )
# # # # # # #             """)
# # # # # # #         conn.commit()
# # # # # # #     finally:
# # # # # # #         conn.close()

# # # # # # # # API endpoint to insert product
# # # # # # # @app.route("/add_product", methods=["POST"])
# # # # # # # def add_product():
# # # # # # #     data = request.get_json()

# # # # # # #     # Validate required fields
# # # # # # #     required_fields = ["name", "brand", "product_type", "size", "expiry", "price", "sku"]
# # # # # # #     for field in required_fields:
# # # # # # #         if field not in data:
# # # # # # #             return jsonify({"error": f"Missing field: {field}"}), 400

# # # # # # #     try:
# # # # # # #         expiry_date = datetime.strptime(data["expiry"], "%d/%m/%y").strftime("%Y-%m-%d")
# # # # # # #     except:
# # # # # # #         expiry_date = None

# # # # # # #     try:
# # # # # # #         conn = pymysql.connect(
# # # # # # #             host=MYSQL_HOST,
# # # # # # #             user=MYSQL_USER,
# # # # # # #             password=MYSQL_PASSWORD,
# # # # # # #             database=DATABASE_NAME
# # # # # # #         )
# # # # # # #         with conn.cursor() as cursor:
# # # # # # #             sql = f"""
# # # # # # #             INSERT INTO {TABLE_NAME} (name, brand, product_type, size, expiry, price, sku)
# # # # # # #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# # # # # # #             """
# # # # # # #             cursor.execute(sql, (
# # # # # # #                 data["name"],
# # # # # # #                 data["brand"],
# # # # # # #                 data["product_type"],
# # # # # # #                 data["size"],
# # # # # # #                 expiry_date,
# # # # # # #                 data["price"],
# # # # # # #                 data["sku"]
# # # # # # #             ))
# # # # # # #         conn.commit()
# # # # # # #         return jsonify({"message": "Product inserted successfully!"}), 201
# # # # # # #     except Exception as e:
# # # # # # #         return jsonify({"error": str(e)}), 500
# # # # # # #     finally:
# # # # # # #         conn.close()

# # # # # # # if __name__ == "__main__":
# # # # # # #     setup_mysql()
# # # # # # #     app.run(host="0.0.0.0",port=5000,debug=True)



# # # # # ###### THIS IS THE FASTAPI CODE FOR STORING JSON RESPONSE INTO THE DATABASE
# # # # # from fastapi import FastAPI, HTTPException
# # # # # from pydantic import BaseModel
# # # # # import pymysql
# # # # # from datetime import datetime

# # # # # app = FastAPI()

# # # # # # MySQL configuration
# # # # # MYSQL_HOST = "localhost"
# # # # # MYSQL_USER = "root"
# # # # # MYSQL_PASSWORD = "ritik@01A"
# # # # # DATABASE_NAME = "scanner"
# # # # # TABLE_NAME = "products"

# # # # # # Pydantic model for request body validation
# # # # # class Product(BaseModel):
# # # # #     name: str
# # # # #     brand: str
# # # # #     product_type: str
# # # # #     size: str
# # # # #     expiry: str
# # # # #     price: str
# # # # #     sku: str

# # # # # # Setup database and table
# # # # # def setup_mysql():
# # # # #     conn = pymysql.connect(
# # # # #         host=MYSQL_HOST,
# # # # #         user=MYSQL_USER,
# # # # #         password=MYSQL_PASSWORD
# # # # #     )
# # # # #     try:
# # # # #         with conn.cursor() as cursor:
# # # # #             cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DATABASE_NAME}")
# # # # #         conn.commit()
# # # # #     finally:
# # # # #         conn.close()

# # # # #     conn = pymysql.connect(
# # # # #         host=MYSQL_HOST,
# # # # #         user=MYSQL_USER,
# # # # #         password=MYSQL_PASSWORD,
# # # # #         database=DATABASE_NAME
# # # # #     )
# # # # #     try:
# # # # #         with conn.cursor() as cursor:
# # # # #             cursor.execute(f"""
# # # # #                 CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
# # # # #                     id INT AUTO_INCREMENT PRIMARY KEY,
# # # # #                     name VARCHAR(255),
# # # # #                     brand VARCHAR(255),
# # # # #                     product_type VARCHAR(100),
# # # # #                     size VARCHAR(50),
# # # # #                     expiry DATE,
# # # # #                     price DECIMAL(10,2),
# # # # #                     sku VARCHAR(50)
# # # # #                 )
# # # # #             """)
# # # # #         conn.commit()
# # # # #     finally:
# # # # #         conn.close()

# # # # # # FastAPI endpoint to insert product
# # # # # @app.post("/add_product")
# # # # # async def add_product(product: Product):
# # # # #     # Validate expiry date
# # # # #     try:
# # # # #         expiry_date = datetime.strptime(product.expiry, "%d/%m/%y").strftime("%Y-%m-%d")
# # # # #     except ValueError:
# # # # #         raise HTTPException(status_code=400, detail="Invalid expiry date format")

# # # # #     try:
# # # # #         # Insert product into MySQL database
# # # # #         conn = pymysql.connect(
# # # # #             host=MYSQL_HOST,
# # # # #             user=MYSQL_USER,
# # # # #             password=MYSQL_PASSWORD,
# # # # #             database=DATABASE_NAME
# # # # #         )
# # # # #         with conn.cursor() as cursor:
# # # # #             sql = f"""
# # # # #             INSERT INTO {TABLE_NAME} (name, brand, product_type, size, expiry, price, sku)
# # # # #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# # # # #             """
# # # # #             cursor.execute(sql, (
# # # # #                 product.name,
# # # # #                 product.brand,
# # # # #                 product.product_type,
# # # # #                 product.size,
# # # # #                 expiry_date,
# # # # #                 product.price,
# # # # #                 product.sku
# # # # #             ))
# # # # #         conn.commit()
# # # # #         return {"message": "Product inserted successfully!"}
# # # # #     except Exception as e:
# # # # #         raise HTTPException(status_code=500, detail=str(e))
# # # # #     finally:
# # # # #         conn.close()

# # # # # # Setup MySQL when starting the FastAPI app
# # # # # @app.on_event("startup")
# # # # # def startup():
# # # # #     setup_mysql()

# # # # # # Host and port setup
# # # # # if __name__ == "__main__":
# # # # #     import uvicorn
# # # # #     uvicorn.run(app, host="0.0.0.0", port=5000)



# # #### ONE INTEGRATED FOR BOTH THE API's

# # from fastapi import FastAPI, HTTPException
# # from fastapi.responses import JSONResponse
# # from pydantic import BaseModel
# # import pymysql
# # import cv2
# # import json
# # from PIL import Image
# # import google.generativeai as genai
# # from datetime import datetime

# # # üîê Gemini Config
# # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # model = genai.GenerativeModel("gemini-2.0-flash")

# # # MySQL configuration
# # MYSQL_HOST = "localhost"
# # MYSQL_USER = "root"
# # MYSQL_PASSWORD = "ritik@01A"
# # DATABASE_NAME = "scanner"
# # TABLE_NAME = "products"

# # # FastAPI app initialization
# # app = FastAPI()

# # # Pydantic model for request body validation (product details)
# # class Product(BaseModel):
# #     name: str
# #     brand: str
# #     product_type: str
# #     size: str
# #     expiry: str
# #     price: str
# #     sku: str

# # # Function to extract product info from image using Gemini AI model
# # def extract_product_info_from_image(frame):
# #     pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
# #     try:
# #         response = model.generate_content([ 
# #             "Extract the product details from this image in JSON format. Only return JSON with keys: name, brand, product_type, size, expiry, price, sku.",
# #             pil_image
# #         ])
# #         raw_text = response.text.strip()
# #         if raw_text.startswith("```json"):
# #             raw_text = raw_text.replace("```json", "").replace("```", "").strip()

# #         data = json.loads(raw_text)

# #         if isinstance(data, list):
# #             data = sorted(data, key=lambda x: sum(bool(v) for v in x.values()), reverse=True)[0]

# #         return {"status": "success", "data": data}

# #     except Exception as e:
# #         return {"status": "error", "message": str(e)}

# # # MySQL database setup and table creation
# # def setup_mysql():
# #     conn = pymysql.connect(
# #         host=MYSQL_HOST,
# #         user=MYSQL_USER,
# #         password=MYSQL_PASSWORD
# #     )
# #     try:
# #         with conn.cursor() as cursor:
# #             cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DATABASE_NAME}")
# #         conn.commit()
# #     finally:
# #         conn.close()

# #     conn = pymysql.connect(
# #         host=MYSQL_HOST,
# #         user=MYSQL_USER,
# #         password=MYSQL_PASSWORD,
# #         database=DATABASE_NAME
# #     )
# #     try:
# #         with conn.cursor() as cursor:
# #             cursor.execute(f"""
# #                 CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
# #                     id INT AUTO_INCREMENT PRIMARY KEY,
# #                     name VARCHAR(255),
# #                     brand VARCHAR(255),
# #                     product_type VARCHAR(100),
# #                     size VARCHAR(50),
# #                     expiry DATE,
# #                     price DECIMAL(10,2),
# #                     sku VARCHAR(50)
# #                 )
# #             """)
# #         conn.commit()
# #     finally:
# #         conn.close()

# # # FastAPI endpoint to add a product to the MySQL database
# # @app.post("/add_product")
# # async def add_product(product: Product):
# #     try:
# #         expiry_date = datetime.strptime(product.expiry, "%d/%m/%y").strftime("%Y-%m-%d")
# #     except ValueError:
# #         raise HTTPException(status_code=400, detail="Invalid expiry date format")

# #     try:
# #         # Insert product into MySQL database
# #         conn = pymysql.connect(
# #             host=MYSQL_HOST,
# #             user=MYSQL_USER,
# #             password=MYSQL_PASSWORD,
# #             database=DATABASE_NAME
# #         )
# #         with conn.cursor() as cursor:
# #             sql = f"""
# #             INSERT INTO {TABLE_NAME} (name, brand, product_type, size, expiry, price, sku)
# #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# #             """
# #             cursor.execute(sql, (
# #                 product.name,
# #                 product.brand,
# #                 product.product_type,
# #                 product.size,
# #                 expiry_date,
# #                 product.price,
# #                 product.sku
# #             ))
# #         conn.commit()
# #         return {"message": "Product inserted successfully!"}
# #     except Exception as e:
# #         raise HTTPException(status_code=500, detail=str(e))
# #     finally:
# #         conn.close()

# # # FastAPI endpoint to capture image and extract product details
# # @app.get("/capture")
# # def capture_and_extract():
# #     cap = cv2.VideoCapture(0)
# #     if not cap.isOpened():
# #         raise HTTPException(status_code=500, detail="Failed to open camera")

# #     ret, frame = cap.read()
# #     cap.release()

# #     if not ret:
# #         raise HTTPException(status_code=500, detail="Failed to capture image")

# #     result = extract_product_info_from_image(frame)

# #     if result["status"] == "success":
# #         # You can integrate this with your MySQL insert operation as needed
# #         product_data = result["data"]
# #         return JSONResponse(content=result)
# #     else:
# #         raise HTTPException(status_code=500, detail=result["message"])

# # # Setup MySQL when starting the FastAPI app
# # @app.on_event("startup")
# # def startup():
# #     setup_mysql()

# # # Host and port setup
# # if __name__ == "__main__":
# #     import uvicorn
# #     uvicorn.run(app, host="0.0.0.0", port=5000)








# # # # # from fastapi import FastAPI, File, UploadFile
# # # # # from fastapi.middleware.cors import CORSMiddleware
# # # # # import google.generativeai as genai
# # # # # from PIL import Image
# # # # # import io
# # # # # import json
# # # # # import threading
# # # # # import cv2
# # # # # import pymysql
# # # # # import re

# # # # # # --- Gemini + DB Configs ---
# # # # # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # # # # model = genai.GenerativeModel("gemini-2.0-flash")

# # # # # DB_CONFIG = {
# # # # #     "host": "localhost",
# # # # #     "user": "root",
# # # # #     "password": "ritik@01A",
# # # # #     "database": "product_database"
# # # # # }

# # # # # # --- Insert into DB ---
# # # # # def insert_into_database(data):
# # # # #     try:
# # # # #         conn = pymysql.connect(**DB_CONFIG)
# # # # #         cursor = conn.cursor()
# # # # #         query = """
# # # # #             INSERT INTO product_info (name, brand, product_type, size, expiry, price, sku)
# # # # #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# # # # #         """
# # # # #         values = (
# # # # #             data.get("name", ""),
# # # # #             data.get("brand", ""),
# # # # #             data.get("product_type", ""),
# # # # #             data.get("size", ""),
# # # # #             data.get("expiry", ""),
# # # # #             data.get("price", ""),
# # # # #             data.get("sku", "")
# # # # #         )
# # # # #         cursor.execute(query, values)
# # # # #         conn.commit()
# # # # #         conn.close()
# # # # #         print("‚úÖ Inserted into DB.")
# # # # #     except Exception as e:
# # # # #         print("‚ùå DB Error:", e)

# # # # # # --- Extract from Image ---
# # # # # def extract_info_from_image(image_bytes):
# # # # #     try:
# # # # #         pil_image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
# # # # #         response = model.generate_content(
# # # # #             [
# # # # #                 """You are an AI OCR system. From the image provided, extract product details and output ONLY a JSON object with the following keys: 
# # # # #                 name, brand, product_type, size, expiry, price, sku.
# # # # #                 Return only the JSON object. Do not include any explanation or markdown formatting like ```.""",
# # # # #                 pil_image
# # # # #             ],
# # # # #             generation_config={
# # # # #                 "temperature": 0.3,
# # # # #                 "top_p": 1,
# # # # #                 "top_k": 40,
# # # # #                 "max_output_tokens": 512,
# # # # #             },
# # # # #             safety_settings={
# # # # #                 "HARASSMENT": "block_none",
# # # # #                 "HATE": "block_none",
# # # # #                 "SEXUAL": "block_none",
# # # # #                 "DANGEROUS": "block_none",
# # # # #             }
# # # # #         )

# # # # #         raw_text = response.text.strip()
# # # # #         print("üîç Gemini Response:", repr(raw_text))

# # # # #         match = re.search(r"\{[\s\S]*\}", raw_text)
# # # # #         if match:
# # # # #             json_data = match.group(0)
# # # # #             return json.loads(json_data)
# # # # #         else:
# # # # #             print("‚ö† No valid JSON object found in Gemini response.")
# # # # #             return {"raw_response": raw_text, "error": "No valid JSON object found"}
# # # # #     except Exception as e:
# # # # #         print("‚ùå Gemini Error:", e)
# # # # #         return {"raw_response": "", "error": str(e)}

# # # # # # --- FastAPI App ---
# # # # # app = FastAPI()

# # # # # # --- CORS ---
# # # # # app.add_middleware(
# # # # #     CORSMiddleware,
# # # # #     allow_origins=["http://localhost:3000"],  # Replace with your frontend IP
# # # # #     allow_credentials=True,
# # # # #     allow_methods=["*"],
# # # # #     allow_headers=["*"],
# # # # # )

# # # # # # --- Image Upload Endpoint ---
# # # # # @app.post("/scan-image")
# # # # # async def scan_image(file: UploadFile = File(...)):
# # # # #     try:
# # # # #         print("called")
# # # # #         image_bytes = await file.read()
# # # # #         extracted_data = extract_info_from_image(image_bytes)
# # # # #         if "error" not in extracted_data:
# # # # #             insert_into_database(extracted_data)
# # # # #             return {"message": "Image scanned and saved", "data": extracted_data}
# # # # #         else:
# # # # #             return {"message": "Failed to extract data", "data": extracted_data}
# # # # #     except Exception as e:
# # # # #         return {"error": str(e)}

# # # # # # --- Start Webcam Feed in Background (for testing) ---
# # # # # def start_webcam_feed():
# # # # #     cap = cv2.VideoCapture(1)
# # # # #     if not cap.isOpened():
# # # # #         print("‚ùå Failed to open camera.")
# # # # #         return

# # # # #     print("Camera started. Press SPACE to capture an image...")

# # # # #     threads = []
# # # # #     image_counter = 0

# # # # #     try:
# # # # #         while True:
# # # # #             ret, frame = cap.read()
# # # # #             if not ret:
# # # # #                 print("‚ùå Failed to capture frame.")
# # # # #                 break

# # # # #             cv2.imshow("Live Product Scanner (SPACE: Capture, Q: Quit)", frame)

# # # # #             key = cv2.waitKey(1) & 0xFF

# # # # #             if key == ord(' '):  # Spacebar pressed
# # # # #                 image_counter += 1
# # # # #                 print(f"üîç Capturing image #{image_counter} and extracting in background...")
# # # # #                 thread_frame = frame.copy()
# # # # #                 t = threading.Thread(target=extract_product_info_from_image, args=(thread_frame, image_counter))
# # # # #                 t.start()
# # # # #                 threads.append(t)

# # # # #             elif key == ord('q'):
# # # # #                 print("üëã Exiting scanner...")
# # # # #                 break

# # # # #     except KeyboardInterrupt:
# # # # #         print("‚õî Scanner interrupted by user.")

# # # # #     # Wait for all threads to finish
# # # # #     print("‚è≥ Waiting for all image processing to complete...")
# # # # #     for t in threads:
# # # # #         t.join()

# # # # #     cap.release()
# # # # #     cv2.destroyAllWindows()
# # # # #     print("All image processing complete.")

# # # # # # Optionally, you can run the webcam feed on startup using threading (for testing)
# # # # # if __name__ == "__main__":
# # # # #     threading.Thread(target=start_webcam_feed, daemon=True).start()





# # # # from fastapi import FastAPI, File, UploadFile
# # # # from fastapi.middleware.cors import CORSMiddleware
# # # # import google.generativeai as genai
# # # # from PIL import Image
# # # # import io
# # # # import json
# # # # import re
# # # # import threading
# # # # import cv2

# # # # # --- Gemini Config ---
# # # # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # # # model = genai.GenerativeModel("gemini-2.0-flash")

# # # # # --- Extract from Image ---
# # # # def extract_info_from_image(image_bytes):
# # # #     try:
# # # #         pil_image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
# # # #         response = model.generate_content(
# # # #             [
# # # #                 """You are an AI OCR system. From the image provided, extract product details and output ONLY a JSON object with the following keys: 
# # # #                 name, brand, product_type, size, expiry, price, sku.
# # # #                 Return only the JSON object. Do not include any explanation or markdown formatting like ```.""",
# # # #                 pil_image
# # # #             ],
# # # #             generation_config={
# # # #                 "temperature": 0.3,
# # # #                 "top_p": 1,
# # # #                 "top_k": 40,
# # # #                 "max_output_tokens": 512,
# # # #             },
# # # #             safety_settings={
# # # #                 "HARASSMENT": "block_none",
# # # #                 "HATE": "block_none",
# # # #                 "SEXUAL": "block_none",
# # # #                 "DANGEROUS": "block_none",
# # # #             }
# # # #         )

# # # #         raw_text = response.text.strip()
# # # #         print("üîç Gemini Response:", repr(raw_text))

# # # #         match = re.search(r"\{[\s\S]*\}", raw_text)
# # # #         if match:
# # # #             json_data = match.group(0)
# # # #             return json.loads(json_data)
# # # #         else:
# # # #             print("‚ö† No valid JSON object found in Gemini response.")
# # # #             return {"raw_response": raw_text, "error": "No valid JSON object found"}
# # # #     except Exception as e:
# # # #         print("‚ùå Gemini Error:", e)
# # # #         return {"raw_response": "", "error": str(e)}

# # # # # --- FastAPI App ---
# # # # app = FastAPI()

# # # # # --- CORS ---
# # # # app.add_middleware(
# # # #     CORSMiddleware,
# # # #     allow_origins=["http://localhost:3000"],  # Replace with your frontend IP
# # # #     allow_credentials=True,
# # # #     allow_methods=["*"],
# # # #     allow_headers=["*"],
# # # # )

# # # # # --- Image Upload Endpoint ---
# # # # @app.post("/scan-image")
# # # # async def scan_image(file: UploadFile = File(...)):
# # # #     try:
# # # #         print("called")
# # # #         image_bytes = await file.read()
# # # #         extracted_data = extract_info_from_image(image_bytes)
# # # #         if "error" not in extracted_data:
# # # #             return {"message": "Image scanned successfully", "data": extracted_data}
# # # #         else:
# # # #             return {"message": "Failed to extract data", "data": extracted_data}
# # # #     except Exception as e:
# # # #         return {"error": str(e)}

# # # # # --- Start Webcam Feed in Background (for testing) ---
# # # # def start_webcam_feed():
# # # #     cap = cv2.VideoCapture(1)
# # # #     if not cap.isOpened():
# # # #         print("‚ùå Failed to open camera.")
# # # #         return

# # # #     print("Camera started. Press SPACE to capture an image...")

# # # #     threads = []
# # # #     image_counter = 0

# # # #     try:
# # # #         while True:
# # # #             ret, frame = cap.read()
# # # #             if not ret:
# # # #                 print("‚ùå Failed to capture frame.")
# # # #                 break

# # # #             cv2.imshow("Live Product Scanner (SPACE: Capture, Q: Quit)", frame)

# # # #             key = cv2.waitKey(1) & 0xFF

# # # #             if key == ord(' '):  # Spacebar pressed
# # # #                 image_counter += 1
# # # #                 print(f"üîç Capturing image #{image_counter} and extracting in background...")
# # # #                 thread_frame = frame.copy()
# # # #                 t = threading.Thread(target=extract_product_info_from_image, args=(thread_frame, image_counter))
# # # #                 t.start()
# # # #                 threads.append(t)

# # # #             elif key == ord('q'):
# # # #                 print("üëã Exiting scanner...")
# # # #                 break

# # # #     except KeyboardInterrupt:
# # # #         print("‚õî Scanner interrupted by user.")

# # # #     # Wait for all threads to finish
# # # #     print("‚è≥ Waiting for all image processing to complete...")
# # # #     for t in threads:
# # # #         t.join()

# # # #     cap.release()
# # # #     cv2.destroyAllWindows()
# # # #     print("All image processing complete.")

# # # # # Optionally, you can run the webcam feed on startup using threading (for testing)
# # # # if __name__ == "__main__":
# # # #     threading.Thread(target=start_webcam_feed, daemon=True).start()



# # # from fastapi import FastAPI, HTTPException
# # # from fastapi.responses import JSONResponse
# # # from fastapi.middleware.cors import CORSMiddleware
# # # from pydantic import BaseModel
# # # import pymysql
# # # import cv2
# # # import json
# # # from PIL import Image
# # # import google.generativeai as genai
# # # from datetime import datetime

# # # # üîê Gemini Config
# # # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # # model = genai.GenerativeModel("gemini-2.0-flash")

# # # # FastAPI setup
# # # app = FastAPI()

# # # # CORS configuration
# # # origins = [
# # #     "http://localhost",  # allow localhost
# # #     "http://localhost:3000",  # for frontend dev server, if applicable
# # #     "*",  # allow all origins (use with caution in production)
# # # ]

# # # app.add_middleware(
# # #     CORSMiddleware,
# # #     allow_origins=origins,  # List of allowed origins
# # #     allow_credentials=True,
# # #     allow_methods=["*"],  # Allow all methods (GET, POST, etc.)
# # #     allow_headers=["*"],  # Allow all headers
# # # )

# # # # MySQL configuration
# # # MYSQL_HOST = "localhost"
# # # MYSQL_USER = "root"
# # # MYSQL_PASSWORD = "ritik@01A"
# # # DATABASE_NAME = "scanner"
# # # TABLE_NAME = "products"

# # # # Pydantic model for request body validation
# # # class Product(BaseModel):
# # #     name: str
# # #     brand: str
# # #     product_type: str
# # #     size: str
# # #     expiry: str
# # #     price: str
# # #     sku: str

# # # # Setup database and table
# # # def setup_mysql():
# # #     conn = pymysql.connect(
# # #         host=MYSQL_HOST,
# # #         user=MYSQL_USER,
# # #         password=MYSQL_PASSWORD
# # #     )
# # #     try:
# # #         with conn.cursor() as cursor:
# # #             cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DATABASE_NAME}")
# # #         conn.commit()
# # #     finally:
# # #         conn.close()

# # #     conn = pymysql.connect(
# # #         host=MYSQL_HOST,
# # #         user=MYSQL_USER,
# # #         password=MYSQL_PASSWORD,
# # #         database=DATABASE_NAME
# # #     )
# # #     try:
# # #         with conn.cursor() as cursor:
# # #             cursor.execute(f"""
# # #                 CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
# # #                     id INT AUTO_INCREMENT PRIMARY KEY,
# # #                     name VARCHAR(255),
# # #                     brand VARCHAR(255),
# # #                     product_type VARCHAR(100),
# # #                     size VARCHAR(50),
# # #                     expiry DATE,
# # #                     price DECIMAL(10,2),
# # #                     sku VARCHAR(50)
# # #                 )
# # #             """)
# # #         conn.commit()
# # #     finally:
# # #         conn.close()

# # # # Extract product info from image
# # # def extract_product_info_from_image(frame):
# # #     pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
# # #     try:
# # #         response = model.generate_content([ 
# # #             "Extract the product details from this image in JSON format. Only return JSON with keys: name, brand, product_type, size, expiry, price, sku.",
# # #             pil_image
# # #         ])
# # #         raw_text = response.text.strip()
# # #         if raw_text.startswith("```json"):
# # #             raw_text = raw_text.replace("```json", "").replace("```", "").strip()

# # #         data = json.loads(raw_text)

# # #         if isinstance(data, list):
# # #             data = sorted(data, key=lambda x: sum(bool(v) for v in x.values()), reverse=True)[0]

# # #         return {"status": "success", "data": data}

# # #     except Exception as e:
# # #         return {"status": "error", "message": str(e)}

# # # # FastAPI endpoint to insert product
# # # @app.post("/add_product")
# # # async def add_product(product: Product):
# # #     # Validate expiry date
# # #     try:
# # #         expiry_date = datetime.strptime(product.expiry, "%d/%m/%y").strftime("%Y-%m-%d")
# # #     except ValueError:
# # #         raise HTTPException(status_code=400, detail="Invalid expiry date format")

# # #     try:
# # #         # Insert product into MySQL database
# # #         conn = pymysql.connect(
# # #             host=MYSQL_HOST,
# # #             user=MYSQL_USER,
# # #             password=MYSQL_PASSWORD,
# # #             database=DATABASE_NAME
# # #         )
# # #         with conn.cursor() as cursor:
# # #             sql = f"""
# # #             INSERT INTO {TABLE_NAME} (name, brand, product_type, size, expiry, price, sku)
# # #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# # #             """
# # #             cursor.execute(sql, (
# # #                 product.name,
# # #                 product.brand,
# # #                 product.product_type,
# # #                 product.size,
# # #                 expiry_date,
# # #                 product.price,
# # #                 product.sku
# # #             ))
# # #         conn.commit()
# # #         return {"message": "Product inserted successfully!"}
# # #     except Exception as e:
# # #         raise HTTPException(status_code=500, detail=str(e))
# # #     finally:
# # #         conn.close()

# # # # FastAPI endpoint for capturing image and storing product data
# # # @app.get("/capture")
# # # def capture_and_extract():
# # #     cap = cv2.VideoCapture(0)
# # #     if not cap.isOpened():
# # #         raise HTTPException(status_code=500, detail="Failed to open camera")

# # #     ret, frame = cap.read()
# # #     cap.release()

# # #     if not ret:
# # #         raise HTTPException(status_code=500, detail="Failed to capture image")

# # #     result = extract_product_info_from_image(frame)

# # #     if result["status"] == "success":
# # #         # Extracted product details
# # #         product_data = result["data"]
# # #         # Add the product to the database
# # #         product = Product(**product_data)
# # #         add_product(product)
# # #         return JSONResponse(content=result)
# # #     else:
# # #         raise HTTPException(status_code=500, detail=result["message"])

# # # # Setup MySQL when starting the FastAPI app
# # # @app.on_event("startup")
# # # def startup():
# # #     setup_mysql()

# # # # Host and port setup
# # # if __name__ == "__main__":
# # #     import uvicorn
# # #     uvicorn.run(app, host="0.0.0.0", port=5000)



# from fastapi import FastAPI, HTTPException, File, UploadFile
# from fastapi.responses import JSONResponse
# from fastapi.middleware.cors import CORSMiddleware
# from pydantic import BaseModel
# from datetime import datetime
# import google.generativeai as genai
# import pymysql
# import cv2
# from PIL import Image
# import io
# import json
# import re
# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# from datetime import datetime
# import mysql.connector

# # Gemini configuration
# genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# model = genai.GenerativeModel("gemini-2.0-flash")

# # Database Configuration
# DB_CONFIG = {
#     "host": "localhost",
#     "user": "root",
#     "password": "ritik@01A",
#     "database": "scanner"
# }
# TABLE_NAME = "products"

# # FastAPI app init
# app = FastAPI()

# # CORS setup
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],  # Update with frontend URL
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# # Pydantic model
# class Product(BaseModel):
#     name: str
#     brand: str
#     product_type: str
#     size: str
#     expiry: str
#     price: str
#     sku: str

# # Database table creation
# def get_db_connection():
#     conn = pymysql.connect(
#         host=DB_CONFIG["host"],
#         user=DB_CONFIG["user"],
#         password=DB_CONFIG["password"]
#     )
#     with conn.cursor() as cursor:
#         cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
#     conn.commit()
#     conn.close()

#     conn = pymysql.connect(**DB_CONFIG)
#     with conn.cursor() as cursor:
#         cursor.execute(f"""
#             CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
#                 id INT AUTO_INCREMENT PRIMARY KEY,
#                 name VARCHAR(255),
#                 brand VARCHAR(255),
#                 product_type VARCHAR(100),
#                 size VARCHAR(50),
#                 expiry DATE,
#                 price DECIMAL(10,2),
#                 sku VARCHAR(50)
#             )
#         """)
#     conn.commit()
#     conn.close()

# # Gemini OCR logic
# def extract_info_from_image(pil_image):
#     try:
#         response = model.generate_content(
#             [
#                 "Extract product details and return ONLY a JSON object with keys: name, brand, product_type, size, expiry, price, sku.",
#                 pil_image
#             ],
#             generation_config={"temperature": 0.3, "top_p": 1, "top_k": 40, "max_output_tokens": 512},
#             safety_settings={"HARASSMENT": "block_none", "HATE": "block_none", "SEXUAL": "block_none", "DANGEROUS": "block_none"},
#         )

#         raw_text = response.text.strip()
#         match = re.search(r"\{[\s\S]*\}", raw_text)
#         if match:
#             return {"status": "success", "data": json.loads(match.group(0))}
#         return {"status": "error", "message": "No valid JSON found"}
#     except Exception as e:
#         return {"status": "error", "message": str(e)}

# # Product schema
# class Product(BaseModel):
#     name: str
#     brand: str
#     price: str
#     expiry: str
#     sku: str
#     size: str
#     product_type: str
            

# # DB insert logic
# def insert_into_database(data):
#     try:
#         conn = get_db_connection()
#         cursor = conn.cursor()

#         query = """
#         INSERT INTO products (name, price, code, tax, total, expiry)
#         VALUES (%s, %s, %s, %s, %s, %s)
#         """
#         values = (
#             data["name"],
#             data["price"],
#             data["code"],
#             data["tax"],
#             data["total"],
#             data["expiry"]
#         )

#         cursor.execute(query, values)
#         conn.commit()
#         cursor.close()
#         conn.close()
#         return True
#     except Exception as e:
#         print("DB Insert Error:", e)
#         return False

# # File Upload Endpoint
# @app.post("/scan-image")
# async def scan_image(file: UploadFile = File(...)):
#     try:
#         print("called")
#         image_bytes = await file.read()
#         pil_image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
#         result = extract_info_from_image(pil_image)

#         if result["status"] == "success":
#             success = insert_into_database(result["data"])
#             if success:
#                 return {"message": "Product extracted and saved", "data": result["data"]}
#             else:
#                 return {"message": "Data extraction successful, DB insert failed", "data": result["data"]}
#         else:
#             return {"message": "Extraction failed", "error": result["message"]}
#     except Exception as e:
#         return {"error": str(e)}

# # Camera Capture Endpoint
# @app.get("/capture")
# def capture_image_and_extract():
#     cap = cv2.VideoCapture(0)
#     if not cap.isOpened():
#         raise HTTPException(status_code=500, detail="Failed to open camera")

#     ret, frame = cap.read()
#     cap.release()

#     if not ret:
#         raise HTTPException(status_code=500, detail="Failed to capture image")

#     pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
#     result = extract_info_from_image(pil_image)

#     if result["status"] == "success":
#         success = insert_into_database(result["data"])
#         if success:
#             return {"message": "Captured, extracted, and saved", "data": result["data"]}
#         else:
#             return {"message": "Captured & extracted, but DB insert failed", "data": result["data"]}
#     else:
#         raise HTTPException(status_code=500, detail=result["message"])

# # Manual Add Product Endpoint
# @app.post("/add_product")
# async def add_product(product: Product):
#     try:
#         print("calledd")
#         data = product.dict()
#         print(data)

#         # Parse and reformat expiry
#         # data["expiry"] = datetime.strptime(data["expiry"], "%d/%m/%y").strftime("%Y-%m-%d")

#         success = insert_into_database(data)
#         if success:
#             return {"message": "‚úÖ Product manually added"}
#         else:
#             raise HTTPException(status_code=500, detail="‚ùå DB insert failed")
#     except ValueError:
#         raise HTTPException(status_code=400, detail="‚ùå Invalid expiry date format. Use DD/MM/YY")
    
# # On app startup
# @app.on_event("startup")
# def startup_event():
#     get_db_connection()


# # Host and port setup
# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=5000)    




# # from fastapi import FastAPI, File, UploadFile
# # from fastapi.middleware.cors import CORSMiddleware
# # from PIL import Image
# # import io
# # import json
# # import pymysql
# # import re
# # import google.generativeai as genai

# # # --- Configure Gemini ---
# # genai.configure(api_key="AIzaSyB9gKOT0r4k73X5i-Gt6JNpfLMxWq3HUa8")
# # model = genai.GenerativeModel("gemini-2.0-flash")

# # # --- Database Config ---
# # DB_CONFIG = {
# #     "host": "localhost",
# #     "user": "root",
# #     "password": "ritik@01A",
# #     "database": "product_database"
# # }

# # # --- FastAPI App ---
# # app = FastAPI()

# # # --- CORS ---
# # app.add_middleware(
# #     CORSMiddleware,
# #     allow_origins=["*"],  # You can restrict this in production
# #     allow_credentials=True,
# #     allow_methods=["*"],
# #     allow_headers=["*"],
# # )

# # # --- Clean Price ---
# # def clean_price(price_str):
# #     match = re.search(r"[\d.,]+", price_str)
# #     if match:
# #         return match.group(0).replace(",", "")
# #     return "0.00"

# # # --- Insert into MySQL ---
# # def insert_into_database(data):
# #     try:
# #         conn = pymysql.connect(**DB_CONFIG)
# #         cursor = conn.cursor()
# #         query = """
# #             INSERT INTO product_info (name, brand, product_type, size, expiry, price, sku)
# #             VALUES (%s, %s, %s, %s, %s, %s, %s)
# #         """
# #         price = clean_price(data.get("price", "0.00"))
# #         values = (
# #             data.get("name", ""),
# #             data.get("brand", ""),
# #             data.get("product_type", ""),
# #             data.get("size", ""),
# #             data.get("expiry", ""),
# #             price,
# #             data.get("sku", "")
# #         )
# #         cursor.execute(query, values)
# #         conn.commit()
# #         conn.close()
# #         print("‚úÖ Data inserted successfully.")
# #     except Exception as e:
# #         print("‚ùå Database Error:", e)

# # # --- Extract from Image using Gemini ---
# # def extract_info_from_image(image_bytes):
# #     try:
# #         image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
# #         response = model.generate_content(
# #             [
# #                 """You are an AI OCR system. From the image provided, extract product details and output ONLY a JSON object with the following keys: 
# #                 name, brand, product_type, size, expiry, price, sku.
# #                 Return only the JSON object. Do not include any explanation or markdown formatting like ```.""",
# #                 image
# #             ],
# #             generation_config={
# #                 "temperature": 0.3,
# #                 "top_p": 1,
# #                 "top_k": 40,
# #                 "max_output_tokens": 512,
# #             },
# #             safety_settings={
# #                 "HARASSMENT": "block_none",
# #                 "HATE": "block_none",
# #                 "SEXUAL": "block_none",
# #                 "DANGEROUS": "block_none",
# #             }
# #         )

# #         raw_text = response.text.strip()
# #         print("üîç Gemini Raw Response:", raw_text)

# #         match = re.search(r"\{[\s\S]*\}", raw_text)
# #         if match:
# #             json_data = match.group(0)
# #             return json.loads(json_data)
# #         else:
# #             return {"error": "No valid JSON found", "raw_response": raw_text}
# #     except Exception as e:
# #         return {"error": str(e), "raw_response": ""}

# # # --- API Route ---
# # @app.post("/scan-image")
# # async def scan_image(file: UploadFile = File(...)):
# #     try:
# #         print("Called")
# #         print(f"üì• Received: {file.filename}")
# #         image_bytes = await file.read()
# #         extracted_data = extract_info_from_image(image_bytes)

# #         if "error" not in extracted_data:
# #             insert_into_database(extracted_data)
# #             return {
# #                 "message": "‚úÖ Data extracted and stored successfully.",
# #                 "data": extracted_data
# #             }
# #         else:
# #             return {
# #                 "message": "‚ùå Failed to extract valid data.",
# #                 "error": extracted_data["error"],
# #                 "response": extracted_data.get("raw_response", "")
# #             }
# #     except Exception as e:
# #         return {"error": str(e)}
